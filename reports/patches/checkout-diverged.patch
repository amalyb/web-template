diff --git a/src/containers/CheckoutPage/CheckoutPageWithPayment.js b/src/containers/CheckoutPage/CheckoutPageWithPayment.js
index 99d28ee74..d21a56cd1 100644
--- a/src/containers/CheckoutPage/CheckoutPageWithPayment.js
+++ b/src/containers/CheckoutPage/CheckoutPageWithPayment.js
@@ -1,7 +1,4 @@
-import React, { useState, useRef, useEffect } from 'react';
-import { Elements } from '@stripe/react-stripe-js';
-import { loadStripe } from '@stripe/stripe-js';
-import { getStripe } from '../../stripe';
+import React, { useState, useRef, useEffect, useCallback } from 'react';
 
 // Import contexts and util modules
 import { FormattedMessage, intlShape } from '../../util/reactIntl';
@@ -12,7 +9,6 @@ import { ensureTransaction } from '../../util/data';
 import { createSlug } from '../../util/urlHelpers';
 import { isTransactionInitiateListingNotFoundError } from '../../util/errors';
 import { getProcess, isBookingProcessAlias } from '../../transactions/transaction';
-import { __DEV__, ADDR_ENABLED } from '../../util/envFlags';
 
 // Import shared components
 import { H3, H4, NamedLink, OrderBreakdown, Page } from '../../components';
@@ -38,6 +34,7 @@ import MobileListingImage from './MobileListingImage';
 import MobileOrderBreakdown from './MobileOrderBreakdown';
 
 import css from './CheckoutPage.module.css';
+import { __DEV__ } from '../../util/envFlags';
 
 // Stripe PaymentIntent statuses, where user actions are already completed
 // https://stripe.com/docs/payments/payment-intents/status
@@ -58,6 +55,18 @@ const paymentFlow = (selectedPaymentMethod, saveAfterOnetimePayment) => {
     : ONETIME_PAYMENT;
 };
 
+// Helper to build customer protectedData from shipping form
+const buildCustomerPD = (shipping, currentUser) => ({
+  customerName: shipping?.recipientName || shipping?.name || '',
+  customerStreet: shipping?.streetAddress || shipping?.street || '',
+  customerStreet2: shipping?.streetAddress2 || shipping?.street2 || '',
+  customerCity: shipping?.city || '',
+  customerState: shipping?.state || '',
+  customerZip: shipping?.zip || shipping?.postalCode || shipping?.zipCode || '',
+  customerPhone: shipping?.phone || '',
+  customerEmail: shipping?.email || currentUser?.attributes?.email || '',
+});
+
 const capitalizeString = s => `${s.charAt(0).toUpperCase()}${s.substr(1)}`;
 
 /**
@@ -99,7 +108,7 @@ const prefixPriceVariantProperties = priceVariant => {
  * @param {Object} config app-wide configs. This contains hosted configs too.
  * @returns orderParams.
  */
-const getOrderParams = (pageData, shippingDetails, optionalPaymentParams, config) => {
+const getOrderParams = (pageData, shippingDetails, optionalPaymentParams, config, formValues = {}) => {
   const quantity = pageData.orderData?.quantity;
   const quantityMaybe = quantity ? { quantity } : {};
   const seats = pageData.orderData?.seats;
@@ -120,14 +129,15 @@ const getOrderParams = (pageData, shippingDetails, optionalPaymentParams, config
   // Manually construct protectedData with shipping and contact info
   const protectedDataMaybe = {
     protectedData: {
-      // Customer info from shippingDetails (using correct field names)
-      customerName: shippingInfo?.name || '',
-      customerStreet: shippingAddress?.line1 || '',
-      customerCity: shippingAddress?.city || '',
-      customerState: shippingAddress?.state || '',
-      customerZip: shippingAddress?.postalCode || '',
-      customerEmail: currentUser?.attributes?.email || '',
-      customerPhone: shippingInfo?.phoneNumber || '',
+      // Customer info from formValues and shippingDetails (using correct field names)
+      customerName: formValues.name || shippingInfo?.name || '',
+      customerStreet: formValues.shipping?.street || shippingAddress?.line1 || '',
+      customerStreet2: formValues.shipping?.street2 || '',
+      customerCity: formValues.shipping?.city || shippingAddress?.city || '',
+      customerState: formValues.shipping?.state || shippingAddress?.state || '',
+      customerZip: formValues.shipping?.zip || shippingAddress?.postalCode || '',
+      customerEmail: formValues.email || currentUser?.attributes?.email || '',
+      customerPhone: formValues.phone || shippingInfo?.phoneNumber || '',
 
       // Provider info from currentUser
       providerName: currentUser?.attributes?.profile?.displayName || '',
@@ -146,7 +156,7 @@ const getOrderParams = (pageData, shippingDetails, optionalPaymentParams, config
   };
 
   // Log the constructed protected data for debugging
-  console.log('ðŸ” Constructed protectedData in getOrderParams:', protectedDataMaybe.protectedData);
+  console.log('[checkout] protectedData keys:', Object.keys(protectedDataMaybe.protectedData));
   console.log('ðŸ“¦ Raw shipping details:', shippingDetails);
   console.log('ðŸ“¦ Extracted shipping info:', shippingInfo);
   console.log('ðŸ“¦ Extracted shipping address:', shippingAddress);
@@ -168,7 +178,7 @@ const getOrderParams = (pageData, shippingDetails, optionalPaymentParams, config
   return orderParams;
 };
 
-const fetchSpeculatedTransactionIfNeeded = (orderParams, pageData, fetchSpeculatedTransaction) => {
+const fetchSpeculatedTransactionIfNeeded = (orderParams, pageData, fetchSpeculatedTransaction, prevKeyRef) => {
   const tx = pageData ? pageData.transaction : null;
   const pageDataListing = pageData.listing;
   const processName =
@@ -184,23 +194,39 @@ const fetchSpeculatedTransactionIfNeeded = (orderParams, pageData, fetchSpeculat
     !hasTransactionPassedPendingPayment(tx, process);
 
   if (shouldFetchSpeculatedTransaction) {
-    const processAlias = pageData.listing.attributes.publicData?.transactionProcessAlias;
-    const transactionId = tx ? tx.id : null;
-    const isInquiryInPaymentProcess =
-      tx?.attributes?.lastTransition === process.transitions.INQUIRE;
-
-    const requestTransition = isInquiryInPaymentProcess
-      ? process.transitions.REQUEST_PAYMENT_AFTER_INQUIRY
-      : process.transitions.REQUEST_PAYMENT;
-    const isPrivileged = process.isPrivileged(requestTransition);
-
-    fetchSpeculatedTransaction(
-      orderParams,
-      processAlias,
-      transactionId,
-      requestTransition,
-      isPrivileged
-    );
+    // Create a stable key based on parameters that should trigger a new fetch
+    const specParams = JSON.stringify({
+      listingId: pageData.listing.id,
+      startDate: orderParams?.bookingStart,
+      endDate: orderParams?.bookingEnd,
+      quantity: orderParams?.quantity,
+      shippingZip: (orderParams?.shippingDetails?.postalCode || '').trim().toUpperCase(),
+      country: (orderParams?.shippingDetails?.country || 'US').toUpperCase(),
+      transactionId: tx?.id,
+    });
+
+    // Only fetch if the key has changed (prevents loops)
+    if (prevKeyRef.current !== specParams) {
+      prevKeyRef.current = specParams;
+      
+      const processAlias = pageData.listing.attributes.publicData?.transactionProcessAlias;
+      const transactionId = tx ? tx.id : null;
+      const isInquiryInPaymentProcess =
+        tx?.attributes?.lastTransition === process.transitions.INQUIRE;
+
+      const requestTransition = isInquiryInPaymentProcess
+        ? process.transitions.REQUEST_PAYMENT_AFTER_INQUIRY
+        : process.transitions.REQUEST_PAYMENT;
+      const isPrivileged = process.isPrivileged(requestTransition);
+
+      fetchSpeculatedTransaction(
+        orderParams,
+        processAlias,
+        transactionId,
+        requestTransition,
+        isPrivileged
+      );
+    }
   }
 };
 
@@ -235,10 +261,12 @@ export const loadInitialDataForStripePayments = ({
   const optionalPaymentParams = {};
   const orderParams = getOrderParams(pageData, shippingDetails, optionalPaymentParams, config);
 
-  fetchSpeculatedTransactionIfNeeded(orderParams, pageData, fetchSpeculatedTransaction);
+  // Use a more robust guard to prevent duplicate calls
+  const prevKeyRef = { current: null };
+  fetchSpeculatedTransactionIfNeeded(orderParams, pageData, fetchSpeculatedTransaction, prevKeyRef);
 };
 
-const handleSubmit = (values, process, props, submitting, setSubmitting) => {
+const handleSubmit = async (values, process, props, stripe, submitting, setSubmitting) => {
   if (submitting) {
     return;
   }
@@ -297,69 +325,77 @@ const handleSubmit = (values, process, props, submitting, setSubmitting) => {
   // Log formValues for debugging
   console.log('Form values on submit:', formValues);
 
-  // Handle both field naming conventions based on flag
+  // Build customer protectedData for request-payment
+  // Filter out empty strings so you don't clobber later merges
+  const protectedData = {};
+  
+  // Customer fields - only include if non-empty
+  if (formValues.customerName?.trim()) protectedData.customerName = formValues.customerName.trim();
+  if (formValues.customerStreet?.trim()) protectedData.customerStreet = formValues.customerStreet.trim();
+  if (formValues.customerStreet2?.trim()) protectedData.customerStreet2 = formValues.customerStreet2.trim();
+  if (formValues.customerCity?.trim()) protectedData.customerCity = formValues.customerCity.trim();
+  if (formValues.customerState?.trim()) protectedData.customerState = formValues.customerState.trim();
+  if (formValues.customerZip?.trim()) protectedData.customerZip = formValues.customerZip.trim();
+  if (formValues.customerEmail?.trim()) protectedData.customerEmail = formValues.customerEmail.trim();
+  else if (currentUser?.attributes?.email?.trim()) protectedData.customerEmail = currentUser.attributes.email.trim();
+  if (formValues.customerPhone?.trim()) protectedData.customerPhone = formValues.customerPhone.trim();
+  
+  // Provider fields - only include if non-empty
+  if (currentUser?.attributes?.profile?.displayName?.trim()) {
+    protectedData.providerName = currentUser.attributes.profile.displayName.trim();
+  }
+  if (currentUser?.attributes?.email?.trim()) {
+    protectedData.providerEmail = currentUser.attributes.email.trim();
+  }
+  const providerPhone = currentUser?.attributes?.profile?.protectedData?.phoneNumber || 
+                       currentUser?.attributes?.profile?.publicData?.phoneNumber;
+  if (providerPhone?.trim()) {
+    protectedData.providerPhone = providerPhone.trim();
+  }
+
+  // Add customer protected data from form values (inline mapping)
+  const customerPD = (function(v){
+    const s = v?.shipping || {};
+    const b = v?.billing || {};
+    const use = v?.shipping && !v?.shippingSameAsBilling ? s : (Object.keys(s||{}).length ? s : b);
+    return {
+      customerName:   use?.name        || '',
+      customerStreet: use?.line1       || '',
+      customerStreet2:use?.line2       || '',
+      customerCity:   use?.city        || '',
+      customerState:  use?.state       || '',
+      customerZip:    use?.postalCode  || '',
+      customerPhone:  use?.phone       || '',
+      customerEmail:  use?.email       || '',
+    };
+  })(formValues);
+
+  const mergedPD = { ...protectedData, ...customerPD };
+  if (__DEV__) {
+    // eslint-disable-next-line no-console
+    console.log('[checkoutâ†’request-payment] Customer PD about to send:', mergedPD);
+  }
 
-  // Resolve borrower fields from either AddressForm (shipping.*) or flat custom fields
-  const addr = ADDR_ENABLED
-    ? {
-        customerName: formValues?.shipping?.name ?? '',
-        customerStreet: formValues?.shipping?.line1 ?? '',
-        customerStreet2: formValues?.shipping?.line2 ?? '',
-        customerCity: formValues?.shipping?.city ?? '',
-        customerState: formValues?.shipping?.state ?? '',
-        customerZip: formValues?.shipping?.postalCode ?? '',
-        customerEmail: formValues?.shipping?.email ?? currentUser?.attributes?.email ?? '',
-        customerPhone: formValues?.shipping?.phone ?? '',
+  // Log the protected data for debugging (production-safe, browser-safe)
+  if (__DEV__) {
+    try {
+      console.log('ðŸ” Protected data constructed from formValues:', mergedPD);
+      console.log('ðŸ“¦ Raw formValues:', formValues);
+      console.log('[checkout] sending protectedData:', Object.entries(mergedPD));
+      
+      // Verify customer fields are populated
+      const customerFields = ['customerName', 'customerStreet', 'customerCity', 'customerState', 'customerZip', 'customerEmail', 'customerPhone'];
+      const missingFields = customerFields.filter(field => !mergedPD[field]?.trim());
+      if (missingFields.length > 0) {
+        console.warn('âš ï¸ Missing customer fields:', missingFields);
+      } else {
+        console.log('âœ… All customer fields populated:', customerFields.map(field => `${field}: "${mergedPD[field]}"`));
       }
-    : {
-        customerName: formValues?.customerName ?? '',
-        customerStreet: formValues?.customerStreet ?? '',
-        customerStreet2: formValues?.customerStreet2 ?? '',
-        customerCity: formValues?.customerCity ?? '',
-        customerState: formValues?.customerState ?? '',
-        customerZip: formValues?.customerZip ?? '',
-        customerEmail: formValues?.customerEmail ?? currentUser?.attributes?.email ?? '',
-        customerPhone: formValues?.customerPhone ?? '',
-      };
-
-  // Client-side validation for required address fields
-  if (!addr.customerStreet || !addr.customerZip) {
-    if (__DEV__) {
-      console.log('ðŸ” Address validation failed:', {
-        customerStreet: addr.customerStreet ? 'present' : 'missing',
-        customerZip: addr.customerZip ? 'present' : 'missing'
-      });
+    } catch (_) {
+      // never block submission on logging
     }
-    setSubmitting(false);
-    throw new Error('Street address and ZIP code are required');
   }
 
-  // Construct protectedData
-  const protectedData = {
-    ...addr,
-    // Provider info from current user
-    providerName: currentUser?.attributes?.profile?.displayName || '',
-    providerStreet: '', // Provider fills later
-    providerCity: '',
-    providerState: '',
-    providerZip: '',
-    providerEmail: currentUser?.attributes?.email || '',
-    providerPhone:
-      currentUser?.attributes?.profile?.protectedData?.phoneNumber ||
-      currentUser?.attributes?.profile?.publicData?.phoneNumber ||
-      '',
-  };
-
-  // Filter out empty strings/nulls so we don't overwrite PD with blanks
-  const filteredProtectedData = Object.fromEntries(
-    Object.entries(protectedData).filter(([, v]) => v !== '' && v != null)
-  );
-
-  // Diagnostics
-  console.debug('[checkout] forwarding PD keys', Object.keys(filteredProtectedData));
-  console.log('ðŸ” Protected data constructed from formValues:', protectedData);
-  console.log('ðŸ“¦ Raw formValues:', formValues);
-
   // Calculate pricing and booking duration
   const unitPrice = pageData?.listing?.attributes?.price;
   const currency = unitPrice?.currency;
@@ -386,14 +422,14 @@ const handleSubmit = (values, process, props, submitting, setSubmitting) => {
     discountPercent = 0.25;
     discountCode = 'line-item/discount-25';
   } else if (nights >= 6 && nights <= 7) {
+    discountPercent = 0.30;
+    discountCode = 'line-item/discount-30';
+  } else if (nights >= 8 && nights <= 10) {
     discountPercent = 0.40;
     discountCode = 'line-item/discount-40';
-  } else if (nights >= 8 && nights <= 9) {
+  } else if (nights >= 11) {
     discountPercent = 0.50;
     discountCode = 'line-item/discount-50';
-  } else if (nights >= 10) {
-    discountPercent = 0.60;
-    discountCode = 'line-item/discount-60';
   }
 
   const preDiscountTotal = baseNightlyPrice * nights;
@@ -444,12 +480,41 @@ const handleSubmit = (values, process, props, submitting, setSubmitting) => {
     bookingStart,
     bookingEnd,
     lineItems,
-    protectedData: filteredProtectedData,  // Now built from form fields, filtered
+    protectedData: mergedPD,  // Use merged protected data with customer fields
     ...optionalPaymentParams,
   };
 
-  // TEMP: Log orderParams before API call
+  // Verify required address fields before API call
+  if (__DEV__) {
+    console.log('[checkoutâ†’request-payment] customerStreet:', mergedPD.customerStreet);
+    console.log('[checkoutâ†’request-payment] customerZip:', mergedPD.customerZip);
+  }
+  
+  // Assert required fields and abort if missing
+  if (!mergedPD.customerStreet?.trim() || !mergedPD.customerZip?.trim()) {
+    const missingFields = [];
+    if (!mergedPD.customerStreet?.trim()) missingFields.push('Street Address');
+    if (!mergedPD.customerZip?.trim()) missingFields.push('ZIP Code');
+    
+    setSubmitting(false);
+    throw new Error(`Please fill in the required address fields: ${missingFields.join(', ')}`);
+  }
+
+  // One-time logs right before the API call
+  console.log('[checkoutâ†’request-payment] protectedData keys:', Object.keys(mergedPD));
   console.log('ðŸ“ Final orderParams being sent to initiateOrder:', orderParams);
+  
+  // Verify customer data is included in the request
+  if (__DEV__) {
+    try {
+      const customerDataInRequest = orderParams.protectedData;
+      const customerFields = ['customerName', 'customerStreet', 'customerCity', 'customerState', 'customerZip', 'customerEmail', 'customerPhone'];
+      const populatedFields = customerFields.filter(field => customerDataInRequest[field]?.trim());
+      console.log(`[checkoutâ†’request-payment] Customer fields in request: ${populatedFields.length}/${customerFields.length}`, populatedFields);
+    } catch (_) {
+      // never block submission on logging
+    }
+  }
 
   // Log line items for debugging
   console.log('ðŸ” Line item codes being sent:', lineItems.map(item => item.code));
@@ -459,7 +524,7 @@ const handleSubmit = (values, process, props, submitting, setSubmitting) => {
   const requestPaymentParams = {
     pageData,
     speculatedTransaction,
-    stripe: values.stripe,
+    stripe,
     card,
     billingDetails: getBillingDetails(formValues, currentUser),
     message,
@@ -480,28 +545,39 @@ const handleSubmit = (values, process, props, submitting, setSubmitting) => {
   };
 
   console.log('ðŸš¦ processCheckoutWithPayment called:', { orderParams, requestPaymentParams });
-  processCheckoutWithPayment(orderParams, requestPaymentParams)
-    .then(response => {
-      const { orderId, messageSuccess, paymentMethodSaved } = response;
-      setSubmitting(false);
-
-      const initialMessageFailedToTransaction = messageSuccess ? null : orderId;
-      const orderDetailsPath = pathByRouteName('OrderDetailsPage', routeConfiguration, {
-        id: orderId.uuid,
-      });
-      const initialValues = {
-        initialMessageFailedToTransaction,
-        savePaymentMethodFailed: !paymentMethodSaved,
-      };
-
-      setOrderPageInitialValues(initialValues, routeConfiguration, dispatch);
-      onSubmitCallback();
-      history.push(orderDetailsPath);
-    })
-    .catch(err => {
-      console.error(err);
-      setSubmitting(false);
+  
+  try {
+    const response = await processCheckoutWithPayment(orderParams, requestPaymentParams);
+    const { orderId, messageSuccess, paymentMethodSaved } = response;
+    setSubmitting(false);
+
+    const initialMessageFailedToTransaction = messageSuccess ? null : orderId;
+    const orderDetailsPath = pathByRouteName('OrderDetailsPage', routeConfiguration, {
+      id: orderId.uuid,
     });
+    const initialValues = {
+      initialMessageFailedToTransaction,
+      savePaymentMethodFailed: !paymentMethodSaved,
+    };
+
+    setOrderPageInitialValues(initialValues, routeConfiguration, dispatch);
+    onSubmitCallback();
+    history.push(orderDetailsPath);
+  } catch (err) {
+    console.error('[Checkout] processCheckoutWithPayment failed:', err);
+    setSubmitting(false);
+    
+    // Show error notification if available
+    if (typeof props.addMarketplaceNotification === 'function') {
+      props.addMarketplaceNotification({
+        type: 'error',
+        message: 'We couldn\'t start the checkout. Please check your info and try again.',
+      });
+    }
+    
+    // Re-throw to ensure form submission state is properly reset
+    throw err;
+  }
 };
 
 /**
@@ -546,11 +622,31 @@ const handleSubmit = (values, process, props, submitting, setSubmitting) => {
  */
 export const CheckoutPageWithPayment = props => {
   const [submitting, setSubmitting] = useState(false);
+  // Initialized stripe library is saved to state - if it's needed at some point here too.
+  const [stripe, setStripe] = useState(null);
+  // Payment element completion state
+  const [paymentElementComplete, setPaymentElementComplete] = useState(false);
+  const [formValues, setFormValues] = useState({});
+  const [formValid, setFormValid] = useState(false);
+  const [stripeElementMounted, setStripeElementMounted] = useState(false);
+  const stripeReady = !!stripeElementMounted;
+
+  const handleFormValuesChange = useCallback((next) => {
+    const prev = JSON.stringify(formValues || {});
+    const json = JSON.stringify(next || {});
+    if (json !== prev) setFormValues(next || {});
+  }, [formValues]);
+  
+  // Ref to prevent speculative transaction loops
+  const prevSpecKeyRef = useRef(null);
+  // Ref to throttle disabled gates logging
+  const lastReasonRef = useRef(null);
 
   const {
     scrollingDisabled,
     speculateTransactionError,
-    speculatedTransaction: speculatedTransactionMaybe,
+    speculativeTransaction, // âœ… normalized name from mapStateToProps
+    speculativeInProgress, // âœ… normalized name from mapStateToProps
     isClockInSync,
     initiateOrderError,
     confirmPaymentError,
@@ -567,6 +663,44 @@ export const CheckoutPageWithPayment = props => {
     config,
   } = props;
 
+  // Handle speculative transaction initiation with proper guards (one-shot)
+  useEffect(() => {
+    const listingId = pageData?.listing?.id?.uuid || pageData?.listing?.id;
+
+    if (!listingId) return;
+
+    // only when listing changes & we still don't have a speculative tx
+    if (!speculativeTransaction?.id && !speculativeInProgress) {
+      const orderParams = getOrderParams(pageData, {}, {}, config, formValues);
+      fetchSpeculatedTransactionIfNeeded(
+        orderParams,
+        pageData,
+        props.fetchSpeculatedTransaction,
+        prevSpecKeyRef // <-- use the stable ref
+      );
+    }
+    // depend on listingId only, so it's a true one-shot per listing
+  }, [pageData?.listing?.id, speculativeTransaction?.id, speculativeInProgress, formValues]);
+
+  // Throttled logging for disabled gates
+  useEffect(() => {
+    const tx = speculativeTransaction;
+    const hasTxId = !!(tx?.id?.uuid || tx?.id);
+    const gates = { 
+      hasSpeculativeTx: hasTxId, 
+      stripeReady, 
+      paymentElementComplete, 
+      formValid, 
+      notSubmitting: !submitting, 
+      notSpeculating: !speculativeInProgress 
+    };
+    const disabledReason = Object.entries(gates).find(([, ok]) => !ok)?.[0] || null;
+    if (disabledReason !== lastReasonRef.current) {
+      lastReasonRef.current = disabledReason;
+      console.log('[Checkout] submit disabled gates:', gates, 'disabledReason:', disabledReason);
+    }
+  }, [speculativeTransaction, stripeReady, paymentElementComplete, formValid, submitting, speculativeInProgress]);
+
   // Since the listing data is already given from the ListingPage
   // and stored to handle refreshes, it might not have the possible
   // deleted or closed information in it. If the transaction
@@ -579,14 +713,14 @@ export const CheckoutPageWithPayment = props => {
 
   const { listing, transaction, orderData } = pageData;
   const existingTransaction = ensureTransaction(transaction);
-  const speculatedTransaction = ensureTransaction(speculatedTransactionMaybe, {}, null);
+  const normalizedSpeculativeTransaction = ensureTransaction(speculativeTransaction, {}, null);
 
   // If existing transaction has line-items, it has gone through one of the request-payment transitions.
-  // Otherwise, we try to rely on speculatedTransaction for order breakdown data.
+  // Otherwise, we try to rely on normalizedSpeculativeTransaction for order breakdown data.
   const tx =
     existingTransaction?.attributes?.lineItems?.length > 0
       ? existingTransaction
-      : speculatedTransaction;
+      : normalizedSpeculativeTransaction;
   const timeZone = listing?.attributes?.availabilityPlan?.timezone;
   const transactionProcessAlias = listing?.attributes?.publicData?.transactionProcessAlias;
 
@@ -669,7 +803,12 @@ export const CheckoutPageWithPayment = props => {
   // If your marketplace works mostly in one country you can use initial values to select country automatically
   // e.g. {country: 'FI'}
 
-  const initialValuesForStripePayment = { name: userName, recipientName: userName };
+  // Note: StripePaymentForm handles its own comprehensive initialValues setup
+  // We only pass userName for legacy compatibility
+  const initialValuesForStripePayment = { 
+    name: userName, 
+    recipientName: userName
+  };
   const askShippingDetails =
     orderData?.deliveryMethod === 'shipping' &&
     !hasTransactionPassedPendingPayment(existingTransaction, process);
@@ -732,38 +871,99 @@ export const CheckoutPageWithPayment = props => {
             {errorMessages.paymentExpiredMessage}
 
             {showPaymentForm ? (
-              <StripePaymentForm
-                className={css.paymentForm}
-                onSubmit={values =>
-                  handleSubmit(values, process, props, submitting, setSubmitting)
-                }
-                inProgress={submitting}
-                formId="CheckoutPagePaymentForm"
-                authorDisplayName={listing?.author?.attributes?.profile?.displayName}
-                showInitialMessageInput={showInitialMessageInput}
-                initialValues={initialValuesForStripePayment}
-                initiateOrderError={initiateOrderError}
-                confirmCardPaymentError={confirmCardPaymentError}
-                confirmPaymentError={confirmPaymentError}
-                hasHandledCardPayment={hasPaymentIntentUserActionsDone}
-                loadingData={!stripeCustomerFetched}
-                defaultPaymentMethod={
-                  hasDefaultPaymentMethod(stripeCustomerFetched, currentUser)
-                    ? currentUser.stripeCustomer.defaultPaymentMethod
-                    : null
-                }
-                paymentIntent={paymentIntent}
-                onStripeInitialized={() => {}}
-                askShippingDetails={askShippingDetails}
-                showPickUplocation={orderData?.deliveryMethod === 'pickup'}
-                listingLocation={listing?.attributes?.publicData?.location}
-                totalPrice={totalPrice}
-                locale={config.localization.locale}
-                stripePublishableKey={config.stripe.publishableKey}
-                marketplaceName={config.marketplaceName}
-                isBooking={isBookingProcessAlias(transactionProcessAlias)}
-                isFuzzyLocation={config.maps.fuzzy.enabled}
-              />
+              <>
+                {(() => {
+                  // Canonical gating (parent)
+                  const tx = speculativeTransaction; // âœ… use normalized name
+                  const hasTxId = !!(tx?.id?.uuid || tx?.id);
+
+                  // Compute stripe readiness (strict boolean)
+                  const stripeReady = !!stripeElementMounted;
+
+                  const gates = {
+                    hasSpeculativeTx: hasTxId,
+                    stripeReady: stripeReady,                 // ðŸ‘ˆ simplified
+                    paymentElementComplete: !!paymentElementComplete,
+                    formValid: formValid,                   // âœ… bubbled up from child form
+                    notSubmitting: !submitting,      // local state (no duck submitInProgress available)
+                    notSpeculating: !speculativeInProgress  // âœ… use normalized name
+                  };
+
+                  const disabledReason = Object.entries(gates).find(([, ok]) => !ok)?.[0] || null;
+                  const submitDisabled = !!disabledReason;
+
+                  return (
+                    <>
+                      {submitDisabled && (
+                        <div style={{ fontSize: 12, opacity: 0.8, marginTop: 8 }}>
+                          Can't submit yet: <code>{disabledReason}</code>
+                        </div>
+                      )}
+                    </>
+                  );
+                })()}
+                <StripePaymentForm
+                  className={css.paymentForm}
+                  onSubmit={values =>
+                    handleSubmit(values, process, props, stripe, submitting, setSubmitting)
+                  }
+                  inProgress={submitting}
+                  formId="CheckoutPagePaymentForm"
+                  authorDisplayName={listing?.author?.attributes?.profile?.displayName}
+                  showInitialMessageInput={showInitialMessageInput}
+                  initialValues={initialValuesForStripePayment}
+                  initiateOrderError={initiateOrderError}
+                  confirmCardPaymentError={confirmCardPaymentError}
+                  confirmPaymentError={confirmPaymentError}
+                  hasHandledCardPayment={hasPaymentIntentUserActionsDone}
+                  loadingData={!stripeCustomerFetched}
+                  defaultPaymentMethod={
+                    hasDefaultPaymentMethod(stripeCustomerFetched, currentUser)
+                      ? currentUser.stripeCustomer.defaultPaymentMethod
+                      : null
+                  }
+                  paymentIntent={paymentIntent}
+                  onStripeInitialized={stripe => setStripe(stripe)}
+                  onStripeElementMounted={(v) => { 
+                    console.log('[Stripe] element mounted:', v);
+                    setStripeElementMounted(!!v);
+                  }}
+                  onFormValuesChange={handleFormValuesChange}
+                  onPaymentElementChange={setPaymentElementComplete}
+                  onFormValidityChange={(v) => { 
+                    console.log('[Form] parent sees valid:', v); 
+                    setFormValid(v); 
+                  }}
+                  requireInPaymentForm={false}  // billing/shipping collected outside this form
+                  submitInProgress={submitting}  // spinner only
+                  submitDisabled={(() => {
+                    const tx = speculativeTransaction; // âœ… use normalized name
+                    const hasTxId = !!(tx?.id?.uuid || tx?.id);
+                    
+                    // Compute stripe readiness (strict boolean)
+                    const stripeReady = !!stripeElementMounted;
+                    
+                    const gates = {
+                      hasSpeculativeTx: hasTxId,
+                      stripeReady: stripeReady,                 // ðŸ‘ˆ simplified
+                      paymentElementComplete: !!paymentElementComplete,
+                      formValid: formValid,
+                      notSubmitting: !submitting,
+                      notSpeculating: !speculativeInProgress, // âœ… use normalized name
+                    };
+                    return !!Object.entries(gates).find(([, ok]) => !ok)?.[0];
+                  })()}
+                  askShippingDetails={askShippingDetails}
+                  showPickUplocation={orderData?.deliveryMethod === 'pickup'}
+                  listingLocation={listing?.attributes?.publicData?.location}
+                  totalPrice={totalPrice}
+                  locale={config.localization.locale}
+                  stripePublishableKey={config.stripe.publishableKey}
+                  marketplaceName={config.marketplaceName}
+                  isBooking={isBookingProcessAlias(transactionProcessAlias)}
+                  isFuzzyLocation={config.maps.fuzzy.enabled}
+                />
+              </>
             ) : null}
           </section>
         </div>
@@ -785,50 +985,4 @@ export const CheckoutPageWithPayment = props => {
   );
 };
 
-// Create Stripe promise once at module level
-const stripePromise = loadStripe(process.env.REACT_APP_STRIPE_PUBLISHABLE_KEY);
-
-// Crash-proof wrapper component
-const CheckoutPageWithPaymentWrapper = (props) => {
-  const [status, setStatus] = React.useState('loading'); // loading | unavailable | ready
-  const [initError, setInitError] = React.useState(null);
-
-  React.useEffect(() => {
-    let on = true;
-    (async () => {
-      try {
-        console.log('[CheckoutDiag] LIVE bundle Stripe key:', process.env.REACT_APP_STRIPE_PUBLISHABLE_KEY?.slice(0,8));
-        const s = await getStripe({ timeoutMs: 8000, retryMs: 2000 });
-        if (!on) return;
-        if (s) { setStatus('ready'); }
-        else { setStatus('unavailable'); }
-      } catch (err) {
-        if (!on) return;
-        console.error('[CheckoutDiag] Stripe initialization failed:', err);
-        setInitError(err);
-        setStatus('unavailable');
-      }
-    })();
-    return () => { on = false; };
-  }, []);
-
-  if (status === 'loading') return <div style={{padding:16}}>Loading secure paymentâ€¦</div>;
-  if (status === 'unavailable') {
-    console.warn('[CheckoutDiag] Stripe failed to load. Check CSP for js.stripe.com, m.stripe.network, api.stripe.com.');
-    return (
-      <div style={{padding:16}}>
-        <h3>Payment temporarily unavailable</h3>
-        <p>We're having trouble loading our payment provider. Please refresh or try again in a moment.</p>
-        {initError && <div style={{color:'red', marginTop:8}}>We couldn't load the secure card form. Please refresh or try another browser.</div>}
-      </div>
-    );
-  }
-
-  return (
-    <Elements stripe={stripePromise} options={{appearance:{theme:'stripe'}}}>
-      <CheckoutPageWithPayment {...props} />
-    </Elements>
-  );
-};
-
-export default CheckoutPageWithPaymentWrapper;
+export default CheckoutPageWithPayment;
diff --git a/src/containers/CheckoutPage/StripePaymentForm/StripePaymentForm.js b/src/containers/CheckoutPage/StripePaymentForm/StripePaymentForm.js
index f5b65794a..670b8b646 100644
--- a/src/containers/CheckoutPage/StripePaymentForm/StripePaymentForm.js
+++ b/src/containers/CheckoutPage/StripePaymentForm/StripePaymentForm.js
@@ -3,15 +3,14 @@
  * Card is not a Final Form field so it's not available trough Final Form.
  * It's also handled separately in handleSubmit function.
  */
-import React, { useState, useRef, useEffect } from 'react';
-import { Form as FinalForm } from 'react-final-form';
+import React, { Component, useEffect } from 'react';
+import { Form as FinalForm, Field, useForm, useFormState } from 'react-final-form';
 import classNames from 'classnames';
-import { CardElement, useElements, useStripe } from '@stripe/react-stripe-js';
 
 import { FormattedMessage, injectIntl } from '../../../util/reactIntl';
 import { propTypes } from '../../../util/types';
 import { ensurePaymentMethodCard } from '../../../util/data';
-import { __DEV__ } from '../../../util/envFlags';
+import { mapToStripeBilling, mapToShippo, normalizeAddress, normalizePhone, validateAddress } from '../../../util/addressHelpers';
 
 import {
   Heading,
@@ -23,45 +22,53 @@ import {
   SavedCardDetails,
   StripePaymentAddress,
 } from '../../../components';
+import AddressForm from '../../../components/AddressForm/AddressForm';
 
 import ShippingDetails from '../ShippingDetails/ShippingDetails';
-import AddressForm from '../../../components/AddressForm/AddressForm';
 
 import css from './StripePaymentForm.module.css';
+import { __DEV__ } from '../../../util/envFlags';
+
+// Extract a single string from either shipping.* or billing.* based on shippingSameAsBilling
+const pickFromShippingOrBilling = (values, field) => {
+  const ship = values?.shipping || {};
+  const bill = values?.shippingSameAsBilling ? (values?.billing || {}) : (values?.shipping || {});
+  // preference: if user filled shipping block, use that; otherwise use billing
+  const fromShipping = ship?.[field];
+  const fromBilling  = (values?.shippingSameAsBilling ? (values?.billing || {}) : (values?.billing || {}))?.[field];
+  return fromShipping ?? fromBilling ?? '';
+};
+
+// Build the flat customer* payload from form values
+const mapToCustomerProtectedData = (values) => {
+  // AddressForm typical keys: name, line1, line2, city, state, postalCode, phone, email
+  const v = values || {};
+  const customerName   = pickFromShippingOrBilling(v, 'name');
+  const customerStreet = pickFromShippingOrBilling(v, 'line1');
+  const customerStreet2= pickFromShippingOrBilling(v, 'line2');
+  const customerCity   = pickFromShippingOrBilling(v, 'city');
+  const customerState  = pickFromShippingOrBilling(v, 'state');
+  const customerZip    = pickFromShippingOrBilling(v, 'postalCode');
+  const customerPhone  = pickFromShippingOrBilling(v, 'phone');
+  const customerEmail  = pickFromShippingOrBilling(v, 'email');
+
+  const pd = {
+    customerName,
+    customerStreet,
+    customerStreet2,
+    customerCity,
+    customerState,
+    customerZip,
+    customerPhone,
+    customerEmail,
+  };
 
-const ADDR_ENABLED = process.env.REACT_APP_CHECKOUT_ADDR_ENABLED === 'true';
-
-// Helper function to flatten AddressForm values to customer PD
-const mapAddressFormToCustomerPD = (values) => {
-  const customerPD = {};
-  
-  // Map billing address fields
-  if (values.billingName) customerPD.customerName = values.billingName;
-  if (values.billingLine1) customerPD.customerStreet = values.billingLine1;
-  if (values.billingLine2) customerPD.customerStreet2 = values.billingLine2;
-  if (values.billingCity) customerPD.customerCity = values.billingCity;
-  if (values.billingState) customerPD.customerState = values.billingState;
-  if (values.billingPostalCode) customerPD.customerZip = values.billingPostalCode;
-  
-  // Map shipping address fields (respecting "same as billing" when present)
-  const useShipping = values.shippingName || values.shippingLine1;
-  if (useShipping) {
-    if (values.shippingName) customerPD.customerName = values.shippingName;
-    if (values.shippingLine1) customerPD.customerStreet = values.shippingLine1;
-    if (values.shippingLine2) customerPD.customerStreet2 = values.shippingLine2;
-    if (values.shippingCity) customerPD.customerCity = values.shippingCity;
-    if (values.shippingState) customerPD.customerState = values.shippingState;
-    if (values.shippingPostalCode) customerPD.customerZip = values.shippingPostalCode;
+  if (__DEV__) {
+    const filled = Object.entries(pd).filter(([_, val]) => !!val).map(([k]) => k);
+    // eslint-disable-next-line no-console
+    console.log('[StripePaymentForm] mapped customer PD:', pd, 'filled:', filled.length, filled);
   }
-  
-  // Map email and phone if available
-  if (values.customerEmail) customerPD.customerEmail = values.customerEmail;
-  if (values.customerPhone) customerPD.customerPhone = values.customerPhone;
-  
-  // Filter out empty strings
-  return Object.fromEntries(
-    Object.entries(customerPD).filter(([_, value]) => value && value.trim() !== '')
-  );
+  return pd;
 };
 
 /**
@@ -127,54 +134,25 @@ const cardStyles = {
   },
 };
 
-const OneTimePaymentWithCardElement = (props) => {
-  const { cardClasses, formId, hasCardError, error, label, intl, marketplaceName, onCardChange } = props;
-  const stripe = useStripe();
-  const elements = useElements();
-  
-  // StrictMode guard: prevent double onReady in dev
-  const mountedOnceRef = useRef(false);
-  
-  // Alias the init callback for proper effect deps
-  const initCb = props.onStripeInitialized;
-  
-  useEffect(() => {
-    // call once stripe instance exists
-    if (typeof initCb === 'function' && typeof stripe !== 'undefined' && stripe) {
-      initCb(stripe);
-    }
-  }, [stripe, initCb]);
-  
+const OneTimePaymentWithCardElement = props => {
+  const {
+    cardClasses,
+    formId,
+    handleStripeElementRef,
+    hasCardError,
+    error,
+    label,
+    intl,
+    marketplaceName,
+  } = props;
   const labelText =
     label || intl.formatMessage({ id: 'StripePaymentForm.saveAfterOnetimePayment' });
-  
-  console.log('[StripeForm] render start');
-  
-  if (!stripe || !elements) {
-    return <div>Initializing payment formâ€¦</div>;
-  }
-  
   return (
     <React.Fragment>
       <label className={css.paymentLabel} htmlFor={`${formId}-card`}>
         <FormattedMessage id="StripePaymentForm.paymentCardDetails" />
       </label>
-      <div className={cardClasses}>
-        <CardElement
-          id={`${formId}-card`}
-          onReady={(el) => {
-            if (mountedOnceRef.current) return;
-            mountedOnceRef.current = true;
-            props.onStripeElementMounted?.(el);
-          }}
-          onChange={(e) => {
-            // e.complete for CardElement; pass the event if needed by parent
-            props.onPaymentElementChange?.(e?.complete ?? e);
-            console.log('[StripeForm] change', {complete: e.complete, empty: e.empty});
-            onCardChange?.(e);
-          }}
-        />
-      </div>
+      <div className={cardClasses} id={`${formId}-card`} ref={handleStripeElementRef} />
       {hasCardError ? <span className={css.error}>{error}</span> : null}
       <div className={css.saveForLaterUse}>
         <FieldCheckbox
@@ -203,12 +181,12 @@ const PaymentMethodSelector = props => {
     formId,
     changePaymentMethod,
     defaultPaymentMethod,
+    handleStripeElementRef,
     hasCardError,
     error,
     paymentMethod,
     intl,
     marketplaceName,
-    onCardChange,
   } = props;
   const last4Digits = defaultPaymentMethod.attributes.card.last4Digits;
   const labelText = intl.formatMessage(
@@ -230,15 +208,12 @@ const PaymentMethodSelector = props => {
         <OneTimePaymentWithCardElement
           cardClasses={cardClasses}
           formId={formId}
+          handleStripeElementRef={handleStripeElementRef}
           hasCardError={hasCardError}
           error={error}
           label={labelText}
           intl={intl}
           marketplaceName={marketplaceName}
-          onCardChange={onCardChange}
-          onStripeInitialized={props.onStripeInitialized}
-          onStripeElementMounted={props.onStripeElementMounted}
-          onPaymentElementChange={props.onPaymentElementChange}
         />
       ) : null}
     </React.Fragment>
@@ -314,6 +289,83 @@ const LocationOrShippingDetails = props => {
   ) : null;
 };
 
+// Utility to copy billing fields to shipping fields
+const copyBillingToShipping = (form) => {
+  const values = form.getState().values || {};
+  const b = values.billing || {};
+  const mapping = {
+    'shipping.name': b.name || '',
+    'shipping.line1': b.line1 || '',
+    'shipping.line2': b.line2 || '',
+    'shipping.city': b.city || '',
+    'shipping.state': b.state || '',
+    'shipping.postalCode': b.postalCode || '',
+    'shipping.country': b.country || '',
+    'shipping.email': b.email || '',
+    'shipping.phone': b.phone || '',
+  };
+  Object.entries(mapping).forEach(([k, v]) => form.change(k, v));
+};
+
+// Shipping section component with checkbox at top
+const ShippingSection = ({ intl, css }) => {
+  const form = useForm();
+  const { values } = useFormState({ subscription: { values: true } });
+
+  const onSameAsBillingChange = (e) => {
+    const checked = !!e.target.checked;
+    form.change('shippingSameAsBilling', checked);
+    if (checked) copyBillingToShipping(form);
+  };
+
+  // Keep shipping in sync when billing changes while checkbox is checked
+  React.useEffect(() => {
+    if (values.shippingSameAsBilling) copyBillingToShipping(form);
+  }, [
+    values.shippingSameAsBilling,
+    values.billing?.name,
+    values.billing?.line1,
+    values.billing?.line2,
+    values.billing?.city,
+    values.billing?.state,
+    values.billing?.postalCode,
+    values.billing?.country,
+    values.billing?.email,
+    values.billing?.phone,
+  ]);
+
+  return (
+    <section aria-labelledby="shippingTitle">
+      <h2 id="shippingTitle" className={css.heading}>
+        <FormattedMessage id="StripePaymentForm.shippingDetails.title" />
+      </h2>
+
+      <div className={css.sameAsBillingRow}>
+        <label className={css.inlineCheckbox} htmlFor="shippingSameAsBilling">
+          <Field
+            id="shippingSameAsBilling"
+            name="shippingSameAsBilling"
+            component="input"
+            type="checkbox"
+            onChange={onSameAsBillingChange}
+          />
+          <span>{intl.formatMessage({ id: 'StripePaymentForm.shippingSameAsBilling' })}</span>
+        </label>
+      </div>
+
+      {!values.shippingSameAsBilling && (
+        <div className={css.fieldStack}>
+          <AddressForm
+            namespace="shipping"
+            requiredFields={{ name: true, line1: true, city: true, state: true, postalCode: true, country: true, email: true, phone: true }}
+            countryAfterZipForUSCA
+          />
+        </div>
+      )}
+    </section>
+  );
+};
+
 const initialState = {
   error: null,
   cardValueValid: false,
@@ -360,78 +412,166 @@ const initialState = {
  * @param {boolean} props.isFuzzyLocation - Whether the location is fuzzy
  * @param {Object} props.intl - The intl object
  */
-function StripePaymentForm(props) {
-  const stripe = useStripe();
-  const elements = useElements();
-  
-  const [state, setState] = useState(initialState);
-  const finalFormAPI = useRef(null);
-
-  // Extract optional callback props
-  const {
-    onFormValuesChange = () => {},
-    onFormValidityChange = () => {},
-    onPaymentElementChange,
-    onStripeInitialized,
-    onStripeElementMounted,
-    ...otherProps
-  } = props;
+class StripePaymentForm extends Component {
+  constructor(props) {
+    super(props);
+    this.state = initialState;
+    this.updateBillingDetailsToMatchShippingAddress = this.updateBillingDetailsToMatchShippingAddress.bind(
+      this
+    );
+    this.handleCardValueChange = this.handleCardValueChange.bind(this);
+    this.handleSubmit = this.handleSubmit.bind(this);
+    this.paymentForm = this.paymentForm.bind(this);
+    this.initializeStripeElement = this.initializeStripeElement.bind(this);
+    this.handleStripeElementRef = this.handleStripeElementRef.bind(this);
+    this.changePaymentMethod = this.changePaymentMethod.bind(this);
+    this.finalFormAPI = null;
+    this.cardContainer = null;
+    
+    // Change guards to prevent unnecessary callbacks
+    this.lastValuesJSON = '';
+    this.lastEffectiveInvalid = undefined;
+    this.reportedMounted = false;
+  }
 
-  console.log('[StripeForm] render start');
+  componentDidMount() {
+    // SSR/boot safety: gate Stripe init
+    if (typeof window !== 'undefined' && window.Stripe && this.props.stripePublishableKey) {
+      const publishableKey = this.props.stripePublishableKey;
+      const {
+        onStripeInitialized,
+        hasHandledCardPayment,
+        defaultPaymentMethod,
+        loadingData,
+      } = this.props;
+      this.stripe = window.Stripe(publishableKey);
+      onStripeInitialized(this.stripe);
+
+      if (!(hasHandledCardPayment || defaultPaymentMethod || loadingData)) {
+        this.initializeStripeElement();
+      }
+    }
+  }
 
-  // Call optional callbacks if provided
-  React.useEffect(() => {
-    if (props.onStripeInitialized && stripe) {
-      props.onStripeInitialized(stripe);
+  componentWillUnmount() {
+    if (this.card) {
+      this.card.removeEventListener('change', this.handleCardValueChange);
+      this.card.unmount();
+      this.card = null;
     }
-  }, [stripe, props.onStripeInitialized]);
-
-  const updateBillingDetailsToMatchShippingAddress = (shouldFill) => {
-    const formApi = finalFormAPI.current;
-    const values = formApi?.getState()?.values || {};
-    if (formApi) {
-      formApi.batch(() => {
-        formApi.change('name', shouldFill ? values.recipientName : '');
-        formApi.change('addressLine1', shouldFill ? values.recipientAddressLine1 : '');
-        formApi.change('addressLine2', shouldFill ? values.recipientAddressLine2 : '');
-        formApi.change('postal', shouldFill ? values.recipientPostal : '');
-        formApi.change('city', shouldFill ? values.recipientCity : '');
-        formApi.change('state', shouldFill ? values.recipientState : '');
-        formApi.change('country', shouldFill ? values.recipientCountry : '');
+    
+    // Notify parent that Stripe element is unmounted and reset guard
+    if (this.props.onStripeElementMounted) {
+      this.props.onStripeElementMounted(false);
+    }
+    this.reportedMounted = false;
+  }
+
+  initializeStripeElement(element) {
+    const elements = this.stripe.elements(stripeElementsOptions);
+
+    if (!this.card) {
+      this.card = elements.create('card', { style: cardStyles });
+      
+      // Ensure the target element exists before mounting
+      const targetElement = element || this.cardContainer;
+      if (!targetElement) {
+        console.warn('[Stripe] No target element available for mounting');
+        return;
+      }
+      
+      this.card.mount(targetElement);
+      this.card.addEventListener('change', this.handleCardValueChange);
+      
+      // Notify parent that Stripe element is mounted (only once)
+      if (!this.reportedMounted) {
+        this.reportedMounted = true;
+        this.props.onStripeElementMounted?.(true);
+      }
+      
+      // EventListener is the only way to simulate breakpoints with Stripe.
+      window.addEventListener('resize', () => {
+        if (this.card) {
+          if (window.innerWidth < 768) {
+            this.card.update({ style: { base: { fontSize: '14px', lineHeight: '24px' } } });
+          } else {
+            this.card.update({ style: { base: { fontSize: '18px', lineHeight: '24px' } } });
+          }
+        }
       });
     }
-  };
+  }
+
+  updateBillingDetailsToMatchShippingAddress(shouldFill) {
+    const formApi = this.finalFormAPI;
+    const values = formApi.getState()?.values || {};
+    formApi.batch(() => {
+      formApi.change('name', shouldFill ? values.recipientName : '');
+      formApi.change('addressLine1', shouldFill ? values.recipientAddressLine1 : '');
+      formApi.change('addressLine2', shouldFill ? values.recipientAddressLine2 : '');
+      formApi.change('postal', shouldFill ? values.recipientPostal : '');
+      formApi.change('city', shouldFill ? values.recipientCity : '');
+      formApi.change('state', shouldFill ? values.recipientState : '');
+      formApi.change('country', shouldFill ? values.recipientCountry : '');
+    });
+  }
 
-  const changePaymentMethod = (changedTo) => {
-    setState(prev => ({ ...prev, paymentMethod: changedTo }));
-    if (changedTo === 'defaultCard' && finalFormAPI.current) {
-      finalFormAPI.current.change('sameAddressCheckbox', undefined);
-    } else if (changedTo === 'replaceCard' && finalFormAPI.current) {
-      finalFormAPI.current.change('sameAddressCheckbox', ['sameAddress']);
-      updateBillingDetailsToMatchShippingAddress(true);
+  changePaymentMethod(changedTo) {
+    if (this.card && changedTo === 'defaultCard') {
+      this.card.removeEventListener('change', this.handleCardValueChange);
+      this.card.unmount();
+      this.card = null;
+      this.setState({ cardValueValid: false });
     }
-  };
+    this.setState({ paymentMethod: changedTo });
+    if (changedTo === 'defaultCard' && this.finalFormAPI) {
+      this.finalFormAPI.change('sameAddressCheckbox', undefined);
+    } else if (changedTo === 'replaceCard' && this.finalFormAPI) {
+      this.finalFormAPI.change('sameAddressCheckbox', ['sameAddress']);
+      this.updateBillingDetailsToMatchShippingAddress(true);
+    }
+  }
 
-  const handleCardChange = (e) => {
-    setState(prev => ({
-      ...prev,
-      cardValueValid: !!e?.complete,
-      error: e?.error ? e.error.message : null,
-    }));
-    window.__cardComplete = !!e?.complete;
-    console.debug('[checkout] cardComplete=%o', !!e?.complete);
-  };
+  handleStripeElementRef(el) {
+    this.cardContainer = el;
+    if (this.stripe && el) {
+      this.initializeStripeElement(el);
+    }
+  }
+
+  handleCardValueChange(event) {
+    const { intl, onPaymentElementChange } = this.props;
+    const { error, complete } = event;
+
+    const postalCode = event.value.postalCode;
+    if (this.finalFormAPI) {
+      this.finalFormAPI.change('postal', postalCode);
+    }
+
+    // Call payment element change callback
+    if (onPaymentElementChange) {
+      onPaymentElementChange(!!complete);
+      console.log('[Stripe] PaymentElement complete:', complete);
+    }
 
-  const handleSubmit = async (values) => {
+    this.setState(prevState => {
+      return {
+        error: error ? stripeErrorTranslation(intl, error) : null,
+        cardValueValid: complete,
+      };
+    });
+  }
+  handleSubmit(values) {
     const {
       onSubmit,
       inProgress,
       formId,
       hasHandledCardPayment,
       defaultPaymentMethod,
-    } = props;
+      submitDisabled,
+    } = this.props;
     const { initialMessage } = values;
-    const { cardValueValid, paymentMethod } = state;
+    const { cardValueValid, paymentMethod } = this.state;
     const hasDefaultPaymentMethod = defaultPaymentMethod?.id;
     const selectedPaymentMethod = getPaymentMethod(paymentMethod, hasDefaultPaymentMethod);
     const { onetimePaymentNeedsAttention } = checkOnetimePaymentFields(
@@ -441,60 +581,114 @@ function StripePaymentForm(props) {
       hasHandledCardPayment
     );
 
+    // Prevent double submit: early-return if submitDisabled (belt & suspenders)
+    if (submitDisabled) {
+      return;
+    }
+
     if (inProgress || onetimePaymentNeedsAttention) {
       // Already submitting or card value incomplete/invalid
       return;
     }
 
-    // Validate required address fields when ADDR_ENABLED is true
-    if (ADDR_ENABLED) {
-      const customerPD = mapAddressFormToCustomerPD(values);
-      if (!customerPD.customerStreet || !customerPD.customerZip) {
-        if (__DEV__) {
-          console.log('ðŸ” Address validation failed in StripePaymentForm:', {
-            customerStreet: customerPD.customerStreet ? 'present' : 'missing',
-            customerZip: customerPD.customerZip ? 'present' : 'missing'
-          });
-        }
-        // Set form-level error - this will be handled by Final Form
-        throw new Error('Street address and ZIP code are required');
-      }
+    // Extract raw form values
+    const rawBilling = values.billing || {};
+    const rawShipping = values.shipping || {};
+    
+    // Normalize addresses (happens before mapping & submit)
+    const billing = normalizeAddress(rawBilling);
+    const shipping = values.shippingSameAsBilling
+      ? normalizeAddress({ ...values.billing, phone: values.billing?.phone || values.shipping?.phone })
+      : normalizeAddress(rawShipping);
+    
+    // Optional: block PO Boxes for couriers (UPS/FedEx). Route to USPS if needed.
+    const isPOBox = /^(P(OST)?\.?\s*O(FFICE)?\.?\s*BOX)\b/i.test((shipping.line1 || '').toUpperCase());
+    if (isPOBox) {
+      throw new Error('PO Boxes are not supported for courier shipping. Please enter a street address.');
     }
+    
+    // Map to service-specific formats
+    const billingForStripe = mapToStripeBilling(billing);
+    const shippingForCourier = mapToShippo({ ...shipping, line2: shipping.line2 || undefined });
+
+    // Map nested form values to flat structure expected by CheckoutPageWithPayment
+    const mappedFormValues = {
+      // Customer fields from shipping (primary) or billing (fallback)
+      customerName: shipping.name || billing.name || '',
+      customerStreet: shipping.line1 || billing.line1 || '',
+      customerStreet2: shipping.line2 || billing.line2 || '',
+      customerCity: shipping.city || billing.city || '',
+      customerState: shipping.state || billing.state || '',
+      customerZip: shipping.postalCode || billing.postalCode || '',
+      customerEmail: shipping.email || billing.email || '',
+      customerPhone: shipping.phone || billing.phone || '',
+      
+      // Include original nested structure for backward compatibility
+      billing: rawBilling,
+      shipping: rawShipping,
+      shippingSameAsBilling: values.shippingSameAsBilling || false,
+    };
 
-    if (!stripe || !elements) {
-      console.warn('[StripeForm] Stripe/Elements not ready yet');
-      return;
+    // Debug logging for form submission
+    if (__DEV__) {
+      console.log('[StripePaymentForm] Submit - Raw form values:', {
+        billing: rawBilling,
+        shipping: rawShipping,
+        shippingSameAsBilling: values.shippingSameAsBilling
+      });
+      console.log('[StripePaymentForm] Submit - Normalized values:', {
+        billing: billing,
+        shipping: shipping
+      });
+      console.log('[StripePaymentForm] Submit - Mapped customer values:', {
+        customerName: mappedFormValues.customerName,
+        customerStreet: mappedFormValues.customerStreet,
+        customerZip: mappedFormValues.customerZip,
+        customerPhone: mappedFormValues.customerPhone
+      });
     }
+
+    // Build customer protected data and merge into params
+    const customerPD = mapToCustomerProtectedData(values);
+    const nextProtectedData = { ...customerPD };
     
-    const card = elements.getElement(CardElement);
-    if (!card) {
-      console.error('[StripeForm] CardElement missing at submit');
-      return;
+    // Verify required address fields are present
+    if (__DEV__) {
+      // eslint-disable-next-line no-console
+      console.log('[StripePaymentForm] onSubmit protectedData keys:', Object.keys(nextProtectedData));
+      console.log('[StripePaymentForm] customerStreet:', nextProtectedData.customerStreet);
+      console.log('[StripePaymentForm] customerZip:', nextProtectedData.customerZip);
+    }
+    
+    // Assert required fields and abort if missing
+    if (!nextProtectedData.customerStreet?.trim() || !nextProtectedData.customerZip?.trim()) {
+      const missingFields = [];
+      if (!nextProtectedData.customerStreet?.trim()) missingFields.push('Street Address');
+      if (!nextProtectedData.customerZip?.trim()) missingFields.push('ZIP Code');
+      
+      throw new Error(`Please fill in the required address fields: ${missingFields.join(', ')}`);
     }
-
-    // Map AddressForm values to customer PD when ADDR_ENABLED is true
-    const customerPD = ADDR_ENABLED ? mapAddressFormToCustomerPD(values) : {};
-    const formValuesWithPD = {
-      ...values,
-      ...(ADDR_ENABLED && Object.keys(customerPD).length > 0 ? customerPD : {})
-    };
 
     const params = {
       message: initialMessage ? initialMessage.trim() : null,
-      card: card,
-      stripe: stripe,
-      elements: elements,
+      card: this.card,
       formId,
-      formValues: formValuesWithPD,
+      formValues: mappedFormValues,
+      protectedData: nextProtectedData,
       paymentMethod: getPaymentMethod(
         paymentMethod,
         ensurePaymentMethodCard(defaultPaymentMethod).id
       ),
+      billingAddress: billingForStripe,
+      shippingAddress: shippingForCourier,
+      // Also provide normalized objects for any custom logic
+      normalizedBilling: billing,
+      normalizedShipping: shipping,
     };
     onSubmit(params);
-  };
+  }
 
-  const paymentForm = (formRenderProps) => {
+  paymentForm(formRenderProps) {
     const {
       className,
       rootClassName,
@@ -522,28 +716,73 @@ function StripePaymentForm(props) {
       isBooking,
       isFuzzyLocation,
       values,
+      errors,
+      submitFailed,
+      hasValidationErrors,
+      dirtySinceLastSubmit,
     } = formRenderProps;
 
-    finalFormAPI.current = formApi;
+    // Detailed form validation logging (avoid printing huge objects)
+    console.log('[Form] invalid:', invalid, 'hasValidationErrors:', hasValidationErrors, 'errors keys:', Object.keys(errors||{}));
 
-    // Call form values change callback if provided
-    React.useEffect(() => {
-      if (onFormValuesChange && values) {
-        onFormValuesChange(values);
-      }
-    }, [values, onFormValuesChange]);
+    this.finalFormAPI = formApi;
+
+    // Compute effective validity (ignore address errors if external form handles them)
+    const requireInPaymentForm = this.props.requireInPaymentForm ?? true;
+    const hasAddressErrors = !!(errors?.billing || errors?.shipping);
+    const effectiveInvalid = requireInPaymentForm ? invalid : (invalid && !hasAddressErrors);
+
+    // ðŸ”’ bubble validity only when it changes
+    if (effectiveInvalid !== this.lastEffectiveInvalid) {
+      this.lastEffectiveInvalid = effectiveInvalid;
+      this.props.onFormValidityChange?.(!effectiveInvalid);
+    }
 
-    // Call form validity change callback if provided
-    React.useEffect(() => {
-      if (onFormValidityChange) {
-        onFormValidityChange(!invalid);
+    // ðŸ”’ bubble values only when they change
+    const nextJSON = JSON.stringify(values || {});
+    if (nextJSON !== this.lastValuesJSON) {
+      this.lastValuesJSON = nextJSON;
+      
+      // Map nested form values to flat structure expected by CheckoutPageWithPayment
+      const mappedValues = {
+        // Customer fields from shipping (primary) or billing (fallback)
+        customerName: values.shipping?.name || values.billing?.name || '',
+        customerStreet: values.shipping?.line1 || values.billing?.line1 || '',
+        customerStreet2: values.shipping?.line2 || values.billing?.line2 || '',
+        customerCity: values.shipping?.city || values.billing?.city || '',
+        customerState: values.shipping?.state || values.billing?.state || '',
+        customerZip: values.shipping?.postalCode || values.billing?.postalCode || '',
+        customerEmail: values.shipping?.email || values.billing?.email || '',
+        customerPhone: values.shipping?.phone || values.billing?.phone || '',
+        
+        // Include original nested structure for backward compatibility
+        billing: values.billing || {},
+        shipping: values.shipping || {},
+        shippingSameAsBilling: values.shippingSameAsBilling || false,
+      };
+      
+      // Debug logging for form values
+      if (__DEV__) {
+        console.log('[StripePaymentForm] Raw form values:', {
+          billing: values.billing,
+          shipping: values.shipping,
+          shippingSameAsBilling: values.shippingSameAsBilling
+        });
+        console.log('[StripePaymentForm] Mapped customer values:', {
+          customerName: mappedValues.customerName,
+          customerStreet: mappedValues.customerStreet,
+          customerZip: mappedValues.customerZip,
+          customerPhone: mappedValues.customerPhone
+        });
       }
-    }, [invalid, onFormValidityChange]);
+      
+      this.props.onFormValuesChange?.(mappedValues);
+    }
 
     const ensuredDefaultPaymentMethod = ensurePaymentMethodCard(defaultPaymentMethod);
     const billingDetailsNeeded = !(hasHandledCardPayment || confirmPaymentError);
 
-    const { cardValueValid, paymentMethod } = state;
+    const { cardValueValid, paymentMethod } = this.state;
     const hasDefaultPaymentMethod = ensuredDefaultPaymentMethod.id;
     const selectedPaymentMethod = getPaymentMethod(paymentMethod, hasDefaultPaymentMethod);
     const { onetimePaymentNeedsAttention, showOnetimePaymentFields } = checkOnetimePaymentFields(
@@ -553,14 +792,12 @@ function StripePaymentForm(props) {
       hasHandledCardPayment
     );
 
-    const submitDisabled = invalid || onetimePaymentNeedsAttention || submitInProgress;
-    console.debug('[checkout] disabled=%o invalid=%o needsCard=%o inProgress=%o',
-      submitDisabled, invalid, onetimePaymentNeedsAttention, submitInProgress);
-    const hasCardError = state.error && !submitInProgress;
+    const submitDisabled = this.props.submitDisabled;   // single source of truth
+    const hasCardError = this.state.error && !submitInProgress;
     const hasPaymentErrors = confirmCardPaymentError || confirmPaymentError;
     const classes = classNames(rootClassName || css.root, className);
     const cardClasses = classNames(css.card, {
-      [css.cardSuccess]: state.cardValueValid,
+      [css.cardSuccess]: this.state.cardValueValid,
       [css.cardError]: hasCardError,
     });
 
@@ -610,7 +847,7 @@ function StripePaymentForm(props) {
         intl={intl}
         form={formApi}
         fieldId={formId}
-        card={null} // No longer using this.card
+        card={this.card}
         locale={locale}
       />
     );
@@ -619,7 +856,7 @@ function StripePaymentForm(props) {
 
     const handleSameAddressCheckbox = event => {
       const checked = event.target.checked;
-      updateBillingDetailsToMatchShippingAddress(checked);
+      this.updateBillingDetailsToMatchShippingAddress(checked);
     };
     const isBookingYesNo = isBooking ? 'yes' : 'no';
 
@@ -632,16 +869,13 @@ function StripePaymentForm(props) {
                 cardClasses={cardClasses}
                 formId={formId}
                 defaultPaymentMethod={ensuredDefaultPaymentMethod}
-                changePaymentMethod={changePaymentMethod}
+                changePaymentMethod={this.changePaymentMethod}
+                handleStripeElementRef={this.handleStripeElementRef}
                 hasCardError={hasCardError}
-                error={state.error}
+                error={this.state.error}
                 paymentMethod={selectedPaymentMethod}
                 intl={intl}
                 marketplaceName={marketplaceName}
-                onCardChange={handleCardChange}
-                onStripeInitialized={props.onStripeInitialized}
-                onStripeElementMounted={props.onStripeElementMounted}
-                onPaymentElementChange={props.onPaymentElementChange}
               />
             ) : (
               <React.Fragment>
@@ -651,158 +885,28 @@ function StripePaymentForm(props) {
                 <OneTimePaymentWithCardElement
                   cardClasses={cardClasses}
                   formId={formId}
+                  handleStripeElementRef={this.handleStripeElementRef}
                   hasCardError={hasCardError}
-                  error={state.error}
+                  error={this.state.error}
                   intl={intl}
                   marketplaceName={marketplaceName}
-                  onCardChange={handleCardChange}
-                  onStripeInitialized={props.onStripeInitialized}
-                  onStripeElementMounted={props.onStripeElementMounted}
-                  onPaymentElementChange={props.onPaymentElementChange}
                 />
               </React.Fragment>
             )}
 
             {showOnetimePaymentFields ? (
-              <React.Fragment>
-                {!ADDR_ENABLED && (
-                  <div className={css.billingDetails}>
-                    <Heading as="h3" rootClassName={css.heading}>
-                      <FormattedMessage id="StripePaymentForm.billingDetails" />
-                    </Heading>
-
-                    {askShippingDetails ? (
-                      <FieldCheckbox
-                        className={css.sameAddressCheckbox}
-                        textClassName={css.sameAddressLabel}
-                        id="sameAddressCheckbox"
-                        name="sameAddressCheckbox"
-                        label={intl.formatMessage({
-                          id: 'StripePaymentForm.sameBillingAndShippingAddress',
-                        })}
-                        value="sameAddress"
-                        useSuccessColor
-                        onChange={handleSameAddressCheckbox}
-                      />
-                    ) : null}
-
-                    <FieldTextInput
-                      className={css.field}
-                      type="text"
-                      id="name"
-                      name="name"
-                      autoComplete="cc-name"
-                      label={billingDetailsNameLabel}
-                      placeholder={billingDetailsNamePlaceholder}
-                    />
-
-                    {billingAddress}
-
-                  </div>
-                )}
-
-                {ADDR_ENABLED && (
-                  <>
-                    <div className="section">
-                      <h3>Billing details</h3>
-                      <AddressForm
-                        namespace="billing"
-                        disabled={false}
-                        requiredFields={{ name: true, line1: true, city: true, state: true, postalCode: true }}
-                        countryAfterZipForUSCA={true}
-                      />
-                    </div>
-
-                    <div className="section">
-                      <h3>Shipping details</h3>
-                      <AddressForm
-                        namespace="shipping"
-                        disabled={false}
-                        requiredFields={{ name: true, line1: true, city: true, state: true, postalCode: true }}
-                        countryAfterZipForUSCA={true}
-                      />
-                    </div>
-                  </>
-                )}
-
-                {!ADDR_ENABLED && (
-                  <>
-                    {/* Shipping Details Section */}
-                  <div className={css.billingDetails}>
-                    <Heading as="h3" rootClassName={css.heading}>
-                      Shipping Details
-                    </Heading>
-                    <FieldTextInput
-                      className={css.field}
-                      type="text"
-                      id="customerName"
-                      name="customerName"
-                      label="Full Name"
-                      required
-                    />
-                    <FieldTextInput
-                      className={css.field}
-                      type="text"
-                      id="customerStreet"
-                      name="customerStreet"
-                      label="Street *"
-                      placeholder="123 Example Street"
-                      required
-                    />
-                    <FieldTextInput
-                      className={css.field}
-                      type="text"
-                      id="customerStreet2"
-                      name="customerStreet2"
-                      label="Street (line 2)"
-                      placeholder="Apt 7"
-                    />
-                    <FieldTextInput
-                      className={css.field}
-                      type="text"
-                      id="customerCity"
-                      name="customerCity"
-                      label="City"
-                      required
-                    />
-                    <FieldTextInput
-                      className={css.field}
-                      type="text"
-                      id="customerState"
-                      name="customerState"
-                      label="State"
-                      required
-                    />
-                    <FieldTextInput
-                      className={css.field}
-                      type="text"
-                      id="customerZip"
-                      name="customerZip"
-                      label="ZIP Code"
-                      required
-                    />
-                    <FieldTextInput
-                      className={css.field}
-                      type="email"
-                      id="customerEmail"
-                      name="customerEmail"
-                      label="Email"
-                      required
-                      validate={value => (!value ? 'Required' : !/^\S+@\S+\.\S+$/.test(value) ? 'Invalid email' : undefined)}
-                    />
-                    <FieldTextInput
-                      className={css.field}
-                      type="tel"
-                      id="customerPhone"
-                      name="customerPhone"
-                      label="Phone Number"
-                      required
-                      validate={value => (!value ? 'Required' : !/^\+?\d{7,15}$/.test(value) ? 'Invalid phone' : undefined)}
-                    />
-                  </div>
-                  </>
-                )}
-              </React.Fragment>
+              <div className={css.billingDetails}>
+                {/* Billing Address */}
+                <AddressForm
+                  namespace="billing"
+                  title="Billing details"
+                  requiredFields={{ name: true, line1: true, city: true, state: true, postalCode: true, country: true, email: true, phone: true }}
+                  countryAfterZipForUSCA
+                />
+
+                {/* Shipping Address */}
+                <ShippingSection intl={intl} css={css} />
+              </div>
             ) : null}
           </React.Fragment>
         ) : loadingData ? (
@@ -835,10 +939,11 @@ function StripePaymentForm(props) {
             <span className={css.errorMessage}>{paymentErrorMessage}</span>
           ) : null}
           <PrimaryButton
-            className={css.submitButton}
+            className={classNames(css.submitButton, { [css.submitButtonDisabled]: submitDisabled })}
             type="submit"
-            inProgress={submitInProgress}
+            inProgress={this.props.submitInProgress}  // just a spinner flag, not a gate
             disabled={submitDisabled}
+            aria-disabled={submitDisabled}
           >
             {billingDetailsNeeded ? (
               <FormattedMessage
@@ -852,6 +957,26 @@ function StripePaymentForm(props) {
               />
             )}
           </PrimaryButton>
+          
+          {/* Customer field validation errors */}
+          {invalid && errors ? (
+            <div style={{ marginTop: 8, fontSize: 12, color: '#d32f2f' }}>
+              {errors.customerName && <div>â€¢ {errors.customerName}</div>}
+              {errors.customerStreet && <div>â€¢ {errors.customerStreet}</div>}
+              {errors.customerCity && <div>â€¢ {errors.customerCity}</div>}
+              {errors.customerState && <div>â€¢ {errors.customerState}</div>}
+              {errors.customerZip && <div>â€¢ {errors.customerZip}</div>}
+              {errors.customerEmail && <div>â€¢ {errors.customerEmail}</div>}
+              {errors.customerPhone && <div>â€¢ {errors.customerPhone}</div>}
+              {/* Show other errors if no customer field errors */}
+              {!errors.customerName && !errors.customerStreet && !errors.customerCity && 
+               !errors.customerState && !errors.customerZip && !errors.customerEmail && 
+               !errors.customerPhone && Object.keys(errors).length > 0 && (
+                <div>Form invalid. First error: <code>{Object.keys(errors)[0]}</code> â†’ <code>{errors[Object.keys(errors)[0]]}</code></div>
+              )}
+            </div>
+          ) : null}
+          
           <p className={css.paymentInfo}>
             <FormattedMessage
               id="StripePaymentForm.submitConfirmPaymentFinePrint"
@@ -865,26 +990,118 @@ function StripePaymentForm(props) {
         <FormattedMessage id="StripePaymentForm.missingStripeKey" />
       </div>
     );
-  };
-
-  if (!stripe || !elements) {
-    return <div>Initializing payment formâ€¦</div>;
   }
 
-  // Add initialValues for shipping fields
-  const initialValues = {
-    customerName: '',
-    customerStreet: '',
-    customerStreet2: '',
-    customerCity: '',
-    customerState: '',
-    customerZip: '',
-    customerEmail: '',
-    customerPhone: '',
-    ...(props.initialValues || {})
-  };
+  render() {
+    const { onSubmit, ...rest } = this.props;
+    
+    // Deep merge initial values to avoid nuking nested fields from previous drafts
+    const defaultInitialValues = {
+      sameAsBilling: false,
+      shippingSameAsBilling: false,
+      billing: {
+        country: 'US',
+        state: '',
+        postalCode: '',
+        name: '',
+        line1: '',
+        line2: '',
+        city: '',
+        email: '',
+        phone: ''
+      },
+      shipping: {
+        country: 'US',
+        state: '',
+        postalCode: '',
+        name: '',
+        line1: '',
+        line2: '',
+        city: '',
+        email: '',
+        phone: ''
+      },
+      // Legacy fields for backward compatibility
+      customerName: '',
+      customerStreet: '',
+      customerStreet2: '',
+      customerCity: '',
+      customerState: '',
+      customerZip: '',
+      customerEmail: '',
+      customerPhone: '',
+    };
+    
+    // Deep merge with any existing initial values
+    const initialValues = {
+      ...defaultInitialValues,
+      ...(rest.initialValues || {}),
+      billing: {
+        ...defaultInitialValues.billing,
+        ...(rest.initialValues?.billing || {})
+      },
+      shipping: {
+        ...defaultInitialValues.shipping,
+        ...(rest.initialValues?.shipping || {})
+      }
+    };
+    
+    const validate = values => {
+      const errors = {};
+      
+      // Only validate billing/shipping if they're collected within this form
+      if (this.props.requireInPaymentForm) {
+        const billErr = validateAddress(values.billing || {}, { requirePhone: false });
+        if (Object.keys(billErr).length) errors.billing = billErr;
+        if (!values.shippingSameAsBilling) {
+          const shipErr = validateAddress(values.shipping || {}, { requirePhone: true });
+          if (Object.keys(shipErr).length) errors.shipping = shipErr;
+        }
+      }
+      
+      // Validate required customer fields for protectedData
+      const shipping = values.shipping || {};
+      const billing = values.billing || {};
+      const effectiveShipping = values.shippingSameAsBilling ? billing : shipping;
+      
+      // Required fields validation
+      if (!effectiveShipping.name?.trim()) {
+        errors.customerName = 'Name is required';
+      }
+      if (!effectiveShipping.line1?.trim()) {
+        errors.customerStreet = 'Street address is required';
+      }
+      if (!effectiveShipping.city?.trim()) {
+        errors.customerCity = 'City is required';
+      }
+      if (!effectiveShipping.state?.trim()) {
+        errors.customerState = 'State is required';
+      }
+      if (!effectiveShipping.postalCode?.trim()) {
+        errors.customerZip = 'ZIP code is required';
+      } else if (!/^\d{5,}$/.test(effectiveShipping.postalCode.trim())) {
+        errors.customerZip = 'ZIP code must be at least 5 digits';
+      }
+      if (!effectiveShipping.email?.trim()) {
+        errors.customerEmail = 'Email is required';
+      } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(effectiveShipping.email.trim())) {
+        errors.customerEmail = 'Please enter a valid email address';
+      }
+      if (!effectiveShipping.phone?.trim()) {
+        errors.customerPhone = 'Phone number is required';
+      } else {
+        const phone = effectiveShipping.phone.trim();
+        // Accept E.164 format (+1234567890) or 10-digit US format
+        if (!/^\+1\d{10}$/.test(phone) && !/^\d{10}$/.test(phone)) {
+          errors.customerPhone = 'Please enter a valid phone number (10 digits or E.164 format)';
+        }
+      }
+      
+      return errors;
+    };
 
-  return <FinalForm onSubmit={handleSubmit} initialValues={initialValues} {...props} render={paymentForm} />;
+    return <FinalForm onSubmit={this.handleSubmit} validate={validate} initialValues={initialValues} {...rest} render={this.paymentForm} />;
+  }
 }
 
-export default injectIntl(StripePaymentForm);
\ No newline at end of file
+export default injectIntl(StripePaymentForm);
